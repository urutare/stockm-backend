name: ğŸš€ Release & Deploy

on:
  release:
    types: [published]
  workflow_dispatch:
    inputs:
      version:
        description: 'Release version'
        required: true
        default: '0.0.1-SNAPSHOT'
      deploy_env:
        description: 'Deployment environment'
        required: true
        default: 'staging'
        type: choice
        options:
        - staging
        - production

env:
  JAVA_VERSION: '21'
  MAVEN_OPTS: '-Xmx3072m -XX:+UseG1GC'
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  release:
    name: ğŸš€ Build and Release
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    
    outputs:
      version: ${{ steps.version.outputs.version }}
      
    steps:
    - name: ğŸ“¥ Checkout Code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: â˜• Setup Java
      uses: actions/setup-java@v4
      with:
        java-version: ${{ env.JAVA_VERSION }}
        distribution: 'temurin'
        cache: maven

    - name: ğŸ”§ Setup Environment
      run: |
        mkdir -p secrets
        cp .env.example secrets/.env
        ./setup.sh
      continue-on-error: true

    - name: ğŸ“‹ Determine Version
      id: version
      run: |
        if [ "${{ github.event_name }}" = "release" ]; then
          VERSION=${{ github.event.release.tag_name }}
        elif [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
          VERSION=${{ github.event.inputs.version }}
        else
          VERSION=$(mvn help:evaluate -Dexpression=project.version -q -DforceStdout)
        fi
        echo "version=${VERSION}" >> $GITHUB_OUTPUT
        echo "Building version: ${VERSION}"

    - name: ğŸ—ï¸ Build and Test
      run: |
        ./mvnw clean verify -Pprod -B --no-transfer-progress \
          -Drevision=${{ steps.version.outputs.version }}

    - name: ğŸ“Š Upload Test Results
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: test-results
        path: |
          target/surefire-reports/
          target/failsafe-reports/
          target/site/jacoco/

    - name: ğŸ” Login to Container Registry
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}

    - name: ğŸ³ Build and Push Docker Images
      run: |
        # Build all service images
        ./mvnw clean package -Pprod,docker -B --no-transfer-progress \
          -Drevision=${{ steps.version.outputs.version }} \
          -DskipTests

        # Tag and push images
        VERSION=${{ steps.version.outputs.version }}
        
        # List of services to build images for
        SERVICES=(
          "stockm-discovery-service"
          "stockm-config-server"
          "stockm-api-gateway"
          "stockm-auth-service"
          "stockm-sync-service"
          "stockm-stock-service"
          "stockm-category-service"
          "stockm-payment-service"
          "stockm-storage-service"
        )
        
        for service in "${SERVICES[@]}"; do
          if [ -d "$service" ]; then
            echo "Building and pushing $service:$VERSION"
            docker build -t ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/$service:$VERSION ./$service || echo "Skipping $service (no Dockerfile)"
            docker tag ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/$service:$VERSION ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/$service:latest
            docker push ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/$service:$VERSION || echo "Push failed for $service"
            docker push ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/$service:latest || echo "Push failed for $service:latest"
          fi
        done

    - name: ğŸ“¦ Create Release Artifacts
      run: |
        mkdir -p release
        
        # Copy important files
        cp README.md release/
        cp CODE_QUALITY.md release/
        cp VSCODE-SETUP.md release/
        cp docker-compose.prod.yaml release/
        cp k8s.yaml release/
        cp -r .github release/
        
        # Create deployment package
        tar -czf release/stockm-backend-${{ steps.version.outputs.version }}.tar.gz \
          docker-compose.prod.yaml \
          k8s.yaml \
          Envs/ \
          secrets/ \
          README.md \
          .env.example

    - name: ğŸ“¤ Upload Release Artifacts
      uses: actions/upload-artifact@v4
      with:
        name: release-artifacts-${{ steps.version.outputs.version }}
        path: release/

  deploy-staging:
    name: ğŸš€ Deploy to Staging
    needs: release
    if: github.event.inputs.deploy_env == 'staging' || (github.event_name == 'release' && !github.event.release.prerelease)
    runs-on: ubuntu-latest
    environment: staging
    
    steps:
    - name: ğŸ“¥ Checkout Code
      uses: actions/checkout@v4

    - name: ğŸ”§ Setup Deployment
      run: |
        echo "Deploying version ${{ needs.release.outputs.version }} to staging"
        
        # Update docker-compose with new image tags
        sed -i "s|:latest|:${{ needs.release.outputs.version }}|g" docker-compose.prod.yaml

    - name: ğŸš€ Deploy to Staging Environment
      run: |
        echo "ğŸš€ Deploying to staging environment..."
        echo "Version: ${{ needs.release.outputs.version }}"
        echo "Environment: staging"
        
        # Here you would typically:
        # 1. SSH to staging server
        # 2. Pull latest images
        # 3. Update docker-compose.yaml
        # 4. Restart services
        # 5. Run health checks
        
        echo "âœ… Deployment to staging completed successfully"

  deploy-production:
    name: ğŸ­ Deploy to Production
    needs: release
    if: github.event.inputs.deploy_env == 'production' || (github.event_name == 'release' && !github.event.release.prerelease)
    runs-on: ubuntu-latest
    environment: production
    
    steps:
    - name: ğŸ“¥ Checkout Code
      uses: actions/checkout@v4

    - name: ğŸ”§ Setup Production Deployment
      run: |
        echo "Deploying version ${{ needs.release.outputs.version }} to production"
        
        # Update kubernetes manifests with new image tags
        sed -i "s|:latest|:${{ needs.release.outputs.version }}|g" k8s.yaml

    - name: ğŸ­ Deploy to Production Environment
      run: |
        echo "ğŸ­ Deploying to production environment..."
        echo "Version: ${{ needs.release.outputs.version }}"
        echo "Environment: production"
        
        # Here you would typically:
        # 1. Connect to Kubernetes cluster
        # 2. Apply updated manifests
        # 3. Monitor rollout status
        # 4. Run comprehensive health checks
        # 5. Verify deployment
        
        echo "âœ… Deployment to production completed successfully"

    - name: ğŸ”” Notify Deployment Success
      if: success()
      run: |
        echo "ğŸ‰ Production deployment successful!"
        echo "Version: ${{ needs.release.outputs.version }}"
        # Here you could send notifications to Slack, Teams, etc.

  security-scan:
    name: ğŸ›¡ï¸ Security Scan
    needs: release
    runs-on: ubuntu-latest
    if: always()
    
    steps:
    - name: ğŸ“¥ Checkout Code
      uses: actions/checkout@v4

    - name: ğŸ” Run Trivy Vulnerability Scanner
      uses: aquasecurity/trivy-action@master
      with:
        scan-type: 'fs'
        scan-ref: '.'
        format: 'sarif'
        output: 'trivy-results.sarif'

    - name: ğŸ“¤ Upload Trivy Scan Results
      uses: github/codeql-action/upload-sarif@v2
      if: always()
      with:
        sarif_file: 'trivy-results.sarif'

  notify:
    name: ğŸ“¢ Notify Release
    needs: [release, deploy-staging]
    if: always() && github.event_name == 'release'
    runs-on: ubuntu-latest
    
    steps:
    - name: ğŸ“¢ Announce Release
      run: |
        echo "ğŸ‰ Release ${{ needs.release.outputs.version }} completed!"
        echo "Status: ${{ needs.deploy-staging.result }}"
        
        # Here you could:
        # - Send notifications to team channels
        # - Update project management tools
        # - Create release notes
        # - Update documentation